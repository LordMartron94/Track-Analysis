from dataclasses import dataclass, field
from typing import Dict

import pandas as pd
from sklearn.utils import deprecated

from track_analysis.components.md_common_python.py_common.logging import HoornLogger
from track_analysis.components.track_analysis.features.data_generation.builders.key_progression_df_builder import \
    KeyProgressionDFBuilder
from track_analysis.components.track_analysis.features.data_generation.builders.main_audio_info_df_builder import \
    MainAudioInfoDFBuilder
from track_analysis.components.track_analysis.features.data_generation.builders.mfcc_df_builder import MfccDFBuilder
from track_analysis.components.track_analysis.features.data_generation.model.header import Header
from track_analysis.components.track_analysis.features.data_generation.pipeline_context import \
    LibraryDataGenerationPipelineContext
from track_analysis.components.track_analysis.library.audio_transformation.feature_extraction.audio_data_feature import \
    AudioDataFeature


@dataclass
class MappedAudioData:
    """A container for the structured DataFrames generated by the ResultsMapper."""
    main_audio_info: pd.DataFrame = field(default_factory=pd.DataFrame)
    mfcc_audio_info: pd.DataFrame = field(default_factory=pd.DataFrame)
    key_progression_audio_info: pd.DataFrame = field(default_factory=pd.DataFrame)

    @staticmethod
    def create_empty():
        """Factory method to create an instance with empty DataFrames."""
        return MappedAudioData()


class ResultsMapper:
    def __init__(self, logger: HoornLogger, feature_to_header_map: Dict[AudioDataFeature, Header]):
        self._main_info_builder = MainAudioInfoDFBuilder(feature_to_header_map)
        self._mfcc_builder = MfccDFBuilder()
        self._key_progression_builder = KeyProgressionDFBuilder(logger)

    def build(self, full_df: pd.DataFrame) -> MappedAudioData:
        """
        Builds structured DataFrames from raw feature data and returns them.
        This is the primary, reusable method.

        Args:
            full_df: DataFrame containing metadata and all calculated features.

        Returns:
            A MappedAudioData object containing the structured DataFrames.
        """
        if full_df.empty:
            return MappedAudioData.create_empty()

        return MappedAudioData(
            main_audio_info=self._main_info_builder.build(full_df),
            mfcc_audio_info=self._mfcc_builder.build(full_df),
            key_progression_audio_info=self._key_progression_builder.build(full_df)
        )

    @deprecated("This method is deprecated and will be removed in a future release.")
    def map_results_to_context(
            self, full_df: pd.DataFrame, context: LibraryDataGenerationPipelineContext
    ) -> None:
        mapped_data = self.build(full_df)

        context.generated_audio_info = mapped_data.main_audio_info
        context.generated_mfcc_audio_info = mapped_data.mfcc_audio_info
        context.generated_key_progression_audio_info = mapped_data.key_progression_audio_info

    @staticmethod
    def set_empty_context(context: LibraryDataGenerationPipelineContext):
        """Sets empty DataFrames on the context for a clean state."""
        empty_data = MappedAudioData.create_empty()
        context.generated_audio_info = empty_data.main_audio_info
        context.generated_mfcc_audio_info = empty_data.mfcc_audio_info
        context.generated_key_progression_audio_info = empty_data.key_progression_audio_info
